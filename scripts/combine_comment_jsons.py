import argparse
import json
import re
from pathlib import Path


def parse_madlibs(
    input_file: Path,
    output_dir: Path,
) -> dict[str, dict[str, str | dict[str, str]]]:
    """

    Args:
        input_file:
        output_dir:

    Returns: Dict mapping filenames to dicts with the following key:value pairs:
        original (str): The original code
        processed (str): The processed code with comments replaced
        comments (dict[str, str]): Dict mapping IDs to original comments
        generated_comments (dict[str, str]): Dict mapping IDs to generated comments
        comment_types (dict[str, str]): Dict mapping IDs to comment types (block | inline)

    """

    master_obj = json.loads(input_file.read_text())
    master_obj = {str(Path(k).with_suffix("")): v for k, v in master_obj.items()}
    for comment_file in output_dir.rglob("*.json"):
        key = comment_file.with_suffix("").name
        if key not in master_obj:
            print(f"Skipping file: {comment_file.name}")
            continue

        master_obj[key]["comment_types"] = {
            k: v.lower()
            for v, k in re.findall(
                r"<(BLOCK|INLINE)_COMMENT (\w{8})>", master_obj[key]["processed"]
            )
        }

        obj = json.loads(comment_file.read_text())

        if "retries" not in obj:
            print(f"Metadata not found in {comment_file}")

        valid_keys = set(master_obj[key]["comments"].keys())
        seen_keys = set(obj["comments"].keys())
        missing_keys = valid_keys.difference(seen_keys)
        invalid_keys = seen_keys.difference(valid_keys)
        if missing_keys:
            print(
                f"{comment_file.relative_to(output_dir)}"
                f" is missing {len(missing_keys)} keys: {missing_keys}"
            )
        if invalid_keys:
            print(
                f"{comment_file.relative_to(output_dir)}"
                f" has invalid keys (skipping): {invalid_keys}"
            )

        for k in invalid_keys:
            del obj["comments"][k]

        obj["generated_comments"] = obj.pop("comments")
        experiment = str(comment_file.relative_to(output_dir).parent)

        master_obj[key][experiment] = obj

    return master_obj


def parse_module(output_dir: Path) -> dict[str, dict[str, str]]:
    """

    Args:
        output_dir:

    Returns: Dict mapping filenames to dicts with the following key:value pairs:
        original (str): The original code
        processed (str): The processed code with comments replaced
        comments (dict[str, str]): Dict mapping IDs to original comments
        generated_comments (dict[str, str]): Dict mapping IDs to generated comments
    """
    pass


parser = argparse.ArgumentParser(
    prog="Mask MUMPS Comments",
    description="Replace MUMPS comments with numbers, to be used in MadLibs-style"
    " automatic documentation evaluation.",
)

parser.add_argument(
    "--input-comments-file",
    type=str,
    default=None,
    help="The .json file generated by `mask_mumps_comments.py`",
)

parser.add_argument(
    "--output-dir",
    type=str,
    required=True,
    help="The directory containing the generated .json files",
)

args = parser.parse_args()
output_dir = Path(args.output_dir).expanduser()
if args.input_comments_file is not None:
    input_file = Path(args.input_comments_file).expanduser()
    obj = parse_madlibs(input_file, output_dir)
else:
    obj = parse_module(output_dir)

(output_dir / "processed.json").write_text(json.dumps(obj, indent=2))
